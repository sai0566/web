<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play 2048!</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            margin: 0;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(135deg, #ff7e5f, #feb47b);
   /* Light orange gradient */
        }

        .game-container-2048 {
            background-color: #fff;
            border-radius: 8px;
            padding: 7px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow */
        }

        #grid-container {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            grid-gap: 12px;
            margin-bottom: 20px;
            touch-action: none;
            position: relative;
            overflow: visible;
        }

        .tile {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            font-weight: bold;
            border-radius: 8px;
            color: #fff;
            background-color: #aaff80; /* Default light green */
            position: relative;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1); /* Small shadow for depth */
            transition: transform 0.2s ease, box-shadow 0.2s ease; /* Smooth transition */
        }

        .tile:active {
            transform: scale(0.95);
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        .tile[data-value="0"] {
            background-color: #d1d8b3; /* Light gray-yellow */
            color: #776e65;
        }

        .tile[data-value="2"] {
            background-color: #aaff80; /* Light green */
            color: #fff;
        }

        .tile[data-value="4"] {
            background-color: #90ee90; /* Light green */
            color: #fff;
        }

        .tile[data-value="8"] {
            background-color: #ffc300; /* Bright yellow */
            color: #fff;
        }

        .tile[data-value="16"] {
            background-color: #ff7f50; /* Coral */
            color: #fff;
        }

        .tile[data-value="32"] {
            background-color: #ff69b4; /* Hot pink */
            color: #fff;
        }

        .tile[data-value="64"] {
            background-color: #fa8072; /* Salmon */
            color: #fff;
        }

        .tile[data-value="128"] {
            background-color: #ba55d3; /* Medium purple */
            color: #fff;
        }

        .tile[data-value="256"] {
            background-color: #8a2be2; /* Blue violet */
            color: #fff;
        }

        .tile[data-value="512"] {
            background-color: #4b0082; /* Dark magenta */
            color: #fff;
        }

        .tile[data-value="1024"] {
            background-color: #228b22; /* Forest green */
            color: #fff;
        }

        .tile[data-value="2048"] {
            background-color: #0000ff; /* Blue */
            color: #fff;
        }

        .score-container-2048 {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }

        .score-box {
            background-color: #fff;
            padding: 12px 18px;
            border-radius: 6px;
            font-weight: bold;
            color: #555;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .score-label {
            font-size: 0.9em;
            color: #888;
        }

        .controls-2048 {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        .restart-button {
            background-color: #ffdb58; /* Yellow */
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 12px 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .restart-button:hover {
            background-color: #f5c518; /* Darker yellow */
            transform: scale(1.05);
            box-shadow: 0 3px 7px rgba(0, 0, 0, 0.15);
        }

        .restart-button:active {
            transform: scale(0.95);
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        .game-message {
            display: none;
            color: #ff0000;
            font-weight: bold;
            margin-top: 20px;
            text-align: center;
            font-size: 1.4em;
            animation: fadeIn 1s ease, pulse 2s infinite alternate;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes pulse {
          from { transform: scale(1); }
          to { transform: scale(1.1); }
        }

        /* New styles for the sparks animation */
        .sparks {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .spark {
            position: absolute;
            background-color: #ffdb58;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            opacity: 0;
            animation: explode 1s ease-out forwards, twinkle 1s infinite alternate;
        }
        @keyframes twinkle {
            from { opacity: 0.6; }
            to { opacity: 1; }
        }

        @keyframes explode {
            0% {
                transform: translate(var(--start-x), var(--start-y)) scale(0);
                opacity: 0;
            }

            50% {
                transform: translate(var(--mid-x), var(--mid-y)) scale(1.5);
                opacity: 1;
            }

            100% {
                transform: translate(var(--end-x), var(--end-y)) scale(0);
                opacity: 0;
            }
        }

        /* New styles for the blast animation */
        /* New styles for the blast animation (rain effect) */
         .blast {
             position: absolute;
             width: 10px;
             height: 10px;
             border-radius: 50%;
             background-color: rgba(255, 223, 0, 0.8);
             opacity: var(--opacity-start);
             transform: translateY(0) scale(var(--scale));
             pointer-events: none;
             z-index: 11;
             animation: rainBlast var(--animation-duration) linear var(--animation-delay) forwards;
         }

         @keyframes rainBlast {
             0% {
                 transform: translate(var(--start-x), var(--start-y)) scale(var(--scale));
                 opacity: var(--opacity-start);
             }
             100% {
                 transform: translate(var(--end-x), var(--end-y)) scale(var(--scale));
                 opacity: var(--opacity-end);
             }
         }
        .game-container-2048 h2{
           color:#f5c518;
           text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="login-box" style="width: auto;">
            <div class="game-container-2048">
                <h2>2048</h2>
                <div class="score-container-2048">
                    <div class="score-box">
                        <div class="score-label">Score</div>
                        <span id="score">0</span>
                    </div>
                    <div class="score-box">
                        <div class="score-label">High Score</div>
                        <span id="highScore">0</span>
                    </div>
                    <button class="restart-button" onclick="init2048()">Restart</button>
                </div>
                <div role="grid" id="grid-container"></div>
                <p class="game-message" id="game-over-message">
                    Game Over! Your score: <span id="final-score"></span>
                </p>
                <div class="sparks" id="sparks-container"></div>
            </div>
            <button onclick="location.href='dashboard.html'">Back to Dashboard</button>
        </div>
    </div>
    <script>
        const gridContainer = document.getElementById('grid-container');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScore');
        const gameOverMessage = document.getElementById('game-over-message');
        const finalScoreDisplay = document.getElementById('final-score');
        const sparksContainer = document.getElementById('sparks-container');
        let grid = [];
        let score = 0;
        let highScore = localStorage.getItem('highScore2048') || 0;

        function init2048() {
            grid = Array.from({
                length: 4
            }, () => Array(4).fill(0));
            score = 0;
            addTile();
            addTile();
            drawGrid();
            updateScore();
            updateHighScore();
            document.addEventListener('keydown', handleKey);
            setupTouchEvents();
            gameOverMessage.style.display = 'none';
            sparksContainer.innerHTML = '';
            lastScore = 0;
        }

        function drawGrid() {
            gridContainer.innerHTML = '';
            for (let row of grid) {
                for (let cell of row) {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.textContent = cell || '';
                    tile.setAttribute('data-value', cell);
                    gridContainer.appendChild(tile);
                }
            }
            updateTileStyles();
        }

        function getTileColor(val) {
            const colors = {
                0: '#d1d8b3',
                2: '#aaff80',
                4: '#90ee90',
                8: '#ffc300',
                16: '#ff7f50',
                32: '#ff69b4',
                64: '#fa8072',
                128: '#ba55d3',
                256: '#8a2be2',
                512: '#4b0082',
                1024: '#228b22',
                2048: '#0000ff'
            };
            return colors[val] || '#3c3a32';
        }

        function updateTileStyles() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                const value = parseInt(tile.getAttribute('data-value')) || 0;
                tile.style.backgroundColor = getTileColor(value);
                tile.textContent = value || '';
            });
        }

        function addTile() {
            const empty = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (grid[i][j] === 0) {
                        empty.push([i, j]);
                    }
                }
            }
            if (empty.length > 0) {
                const randomIndex = Math.floor(Math.random() * empty.length);
                const [i, j] = empty[randomIndex];
                grid[i][j] = Math.random() < 0.9 ? 2 : 4;
                return true;
            }
            return false;
        }

        function isGameOver() {
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (grid[i][j] === 0) return false;
                    if (j < 3 && grid[i][j] === grid[i][j + 1]) return false;
                    if (i < 3 && grid[i][j] === grid[i + 1][j]) return false;
                }
            }
            return true;
        }

        let lastScore = 0;

        function updateScore(points = 0, row = -1, col = -1) {
            score += points;
            scoreDisplay.textContent = score;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore2048', highScore);
                updateHighScore();
            }
            const scoreThreshold = 1000;
            if (score % scoreThreshold === 0 && score > 0) {
                triggerBlastAnimation(gridContainer);
                triggerSparksAnimation();
                lastScore = score; // Update lastScore to the current score
            }
        }
        function updateHighScore() {
            highScoreDisplay.textContent = highScore;
        }

        function handleKey(e) {
            if (gameOverMessage.style.display === 'block') {
                return;
            }

            let moved = false;
            if (e.key === 'ArrowUp') moved = move('up');
            else if (e.key === 'ArrowDown') moved = move('down');
            else if (e.key === 'ArrowLeft') moved = move('left');
            else if (e.key === 'ArrowRight') moved = move('right');

            if (moved) {
                addTile();
                drawGrid();
                if (isGameOver()) {
                    gameOverMessage.style.display = 'block';
                    finalScoreDisplay.textContent = score;
                    document.removeEventListener('keydown', handleKey);
                }
            }
        }

        function move(dir) {
            let moved = false;
            const size = 4;

            const mergeRow = (row) => {
                const nonZero = row.filter(val => val !== 0);
                const merged = [];
                let i = 0;
                while (i < nonZero.length) {
                    if (i + 1 < nonZero.length && nonZero[i] === nonZero[i + 1]) {
                        const mergedValue = nonZero[i] * 2;
                        merged.push(mergedValue);
                        updateScore(mergedValue, row, i);
                        i += 2;
                        moved = true;
                    } else {
                        merged.push(nonZero[i]);
                        i++;
                    }
                }
                while (merged.length < size) {
                    merged.push(0);
                }
                return merged;
            };

            if (dir === 'up') {
                for (let j = 0; j < size; j++) {
                    const column = grid.map(row => row[j]);
                    const mergedColumn = mergeRow(column);
                    for (let i = 0; i < size; i++) {
                        if (grid[i][j] !== mergedColumn[i]) {
                            grid[i][j] = mergedColumn[i];
                            moved = true;
                        }
                    }
                }
            } else if (dir === 'down') {
                for (let j = 0; j < size; j++) {
                    const column = grid.map(row => row[j]).reverse();
                    const mergedColumn = mergeRow(column).reverse();
                    for (let i = 0; i < size; i++) {
                        if (grid[i][j] !== mergedColumn[i]) {
                            grid[i][j] = mergedColumn[i];
                            moved = true;
                        }
                    }
                }
            } else if (dir === 'left') {
                for (let i = 0; i < size; i++) {
                    const row = grid[i];
                    const mergedRow = mergeRow(row);
                    if (JSON.stringify(grid[i]) !== JSON.stringify(mergedRow)) {
                        grid[i] = mergedRow;
                        moved = true;
                    }
                }
            } else if (dir === 'right') {
                for (let i = 0; i < size; i++) {
                    const row = grid[i].slice().reverse();
                    const mergedRow = mergeRow(row).reverse();
                    if (JSON.stringify(grid[i]) !== JSON.stringify(mergedRow)) {
                        grid[i] = mergedRow;
                        moved = true;
                    }
                }
            }

            return moved;
        }

        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        function setupTouchEvents() {
            gridContainer.addEventListener('touchstart', handleTouchStart, false);
            gridContainer.addEventListener('touchmove', handleTouchMove, false);
            gridContainer.addEventListener('touchend', handleTouchEnd, false);
        }

        function handleTouchStart(event) {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }

        function handleTouchMove(event) {
            if (!event.touches.length) return;

            touchEndX = event.touches[0].clientX;
            touchEndY = event.touches[0].clientY;
        }

        function handleTouchEnd(event) {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 50) {
                    move('right');
                } else if (deltaX < -50) {
                    move('left');
                }
            } else {
                if (deltaY > 50) {
                    move('down');
                } else if (deltaY < -50) {
                    move('up');
                }
            }

            if (Math.abs(deltaX) > 50 || Math.abs(deltaY) > 50) {
                addTile();
                drawGrid();
                if (isGameOver()) {
                    gameOverMessage.style.display = 'block';
                    finalScoreDisplay.textContent = score;
                    document.removeEventListener('keydown', handleKey);
                }
            }

            touchStartX = 0;
            touchStartY = 0;
            touchEndX = 0;
            touchEndY = 0;
        }

        function triggerSparksAnimation() {
            const numSparks = 100;
            const containerRect = gridContainer.getBoundingClientRect();

            for (let i = 0; i < numSparks; i++) {
                const spark = document.createElement('div');
                spark.className = 'spark';
                const startX = Math.random() * containerRect.width;
                const startY = Math.random() * containerRect.height;
                const endX = startX + (Math.random() - 0.5) * 250;
                const endY = startY + (Math.random() - 0.5) * 250;
                const midX = (startX + endX) / 2 + (Math.random() - 0.5) * 120;
                const midY = (startY + endY) / 2 + (Math.random() - 0.5) * 120;
                spark.style.setProperty('--start-x', `${startX}px`);
                spark.style.setProperty('--start-y', `${startY}px`);
                spark.style.setProperty('--mid-x', `${midX}px`);
                spark.style.setProperty('--mid-y', `${midY}px`);
                spark.style.setProperty('--end-x', `${endX}px`);
                spark.style.setProperty('--end-y', `${endY}px`);
                sparksContainer.appendChild(spark);
                spark.addEventListener('animationend', () => spark.remove());
            }
        }

        function triggerBlastAnimation(container) {
                  const containerRect = container.getBoundingClientRect();
                  const numParticles = 120; // Increase number of particles for a rain effect
                  const duration = 2500; // Adjust duration for the falling effect
                  const delayFactor = 0.05; // Reduce delay for a more continuous rain

                  for (let i = 0; i < numParticles; i++) {
                      const particle = document.createElement('div');
                      particle.className = 'blast';
                      const size = Math.random() * 10 + 5; // Vary particle size
                      particle.style.width = `${size}px`;
                      particle.style.height = `${size}px`;
                      const startX = Math.random() * containerRect.width; // Start at random X
                      const startY = -size; // Start above the container
                      const endX = startX + (Math.random() - 0.5) * 40; // Slight horizontal drift
                      const endY = containerRect.height + size; // Fall below the container
                      const scale = Math.random() * 0.7 + 0.6; // Vary scale

                      const delay = i * delayFactor;
                      const hue = Math.random() * 50 + 50; // Vary color slightly
                      particle.style.backgroundColor = `hsla(${hue}, 100%, 50%, 0.7)`;
                      const opacityStart = Math.random() * 0.6 + 0.4;
                      const opacityEnd = 0;

                      particle.style.setProperty('--start-x', `${startX}px`);
                      particle.style.setProperty('--end-x', `${endX}px`);
                      particle.style.setProperty('--start-y', `${startY}px`);
                      particle.style.setProperty('--end-y', `${endY}px`);
                      particle.style.setProperty('--scale', `${scale}`);
                      particle.style.setProperty('--opacity-start', `${opacityStart}`);
                      particle.style.setProperty('--opacity-end', `${opacityEnd}`);
                      particle.style.animationDuration = `${duration}ms`;
                      particle.style.animationDelay = `${delay}ms`;

                      container.appendChild(particle);
                      particle.addEventListener('animationend', () => particle.remove());
                  }
              }

        init2048();
    </script>
</body>
</html>
